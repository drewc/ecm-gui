#+TITLE: SQL: Database <-> Servers <-> Clients

* JavaScript: Client objects and functions

#+begin_src json
{
  name: "SQLStatement",
  type: Object,
  fields: {
    query: "String: The Query SQL text",
    args: "Array: The $args passed to this.query"
    cols: "Array: The names of the columns returned",
    rows: "Array of Arrays: A vector of vectors of the query results"
    complete: "Boolean: If this statement has been run"
  }
}
#+end_src

#+begin_src js :tangle src/assets/sql/objects.js

export function SQLCommand(cmd) {
    Object.assign(this, { complete: false }, cmd)
}

export function SQLStatement(stmt) {
    Object.assign(this, { complete: !!stmt.rows }, stmt)
}

SQLStatement.prototype = Object.create(SQLCommand.prototype);
SQLStatement.prototype.constructor = SQLStatement;

export default { SQLCommand, SQLStatement };

#+end_src

* Catalog


A lot of the time we simply want a string or number input/output and not our wonderful gerbil objects.

#+begin_src scheme :noweb-ref simple-catalog
(extern namespace: "drewc/db/postgresql"
  serialize-boolean deserialize-boolean
  identity-string)

(defcatalog simple-catalog
  ;; BOOLOID
  ((16) serialize-boolean deserialize-boolean)
  ;; INT8OID INT2OID INT4OID FLOAT4OID FLOAT8OID NUMERICOID
  ((20 21 23 700 701 1700) number->string string->number)
  ;; CHAROID TEXTOID BPCHAROID VARCHAROID
  ((18 25 1042 1043) identity-string identity))
#+end_src

That way we can put on passing data to the browser.

#+begin_src scheme
(parameterize ((current-catalog simple-catalog))
  (sql-eval-query (db<-uuid db-uuid) "SELECT now(), 1, '42', false"))

;; => (#("2021-10-25 20:54:35.377459+00" 1 "42", #f))
#+end_src


** /File/ ~catalog.ss~
:PROPERTIES:
:ID:       d7b92dcb-18f0-4df6-8b96-e7a417d2dd2d
:END:
#+begin_src scheme :tangle database/catalog.ss :noweb yes
(export #t)
(import :drewc/db/postgresql  :drewc/db/postgresql-driver
        :drewc/db/dbi :std/text/json)

<<simple-catalog>>

;; (def (serialize-json gerbil-json)
;;  (call-with-output-string "" (cut write-json gerbil-json <>)))

;; (def (deserialize-json str)
;;   (call-with-input-string str read-json))

;; (defcatalog-default ((114 3802) serialize-json deserialize-json))
#+end_src
* Connect and Eval

When a user has been [[file:Authorization.org][Authorized]] the database will re-authorize the connection
with ~current-auth-user~ as the role.

In short, ~ecm-sql-e*~ is used to execute a function in that environment.

#+begin_src scheme
(ecm-sql-e* fn . args) => (apply fn database args)
#+end_src

#+begin_src scheme :tangle database/connect.ss
(export #t)
(import :drewc/ftw :std/misc/uuid :std/sugar
        :drewc/db/postgresql :drewc/db/dbi
        :drewc/pg/connect :std/error
        :std/db/conpool :std/format ../auth ./catalog)

(def ecm-pg-connect-args [ host: "ecm.maxwellclaims.net"
                           user: "maxclaims" ])
(def ecm-sql-conpool
  (make-conpool (cut apply connect ecm-pg-connect-args)
                100))

(def (ecm-sql-e role: (role "mr_read")
                fn . args)
  (def con (conpool-get ecm-sql-conpool 5))
  (def err #f)
  (try
   (sql-eval con (format "SET SESSION AUTHORIZATION \"~a\""
                         role))

   (parameterize ((current-catalog simple-catalog))
     (apply fn con args))
   (catch (e) (set! err e))
   (finally
    (cond (err
           (conpool-release ecm-sql-conpool con)
           (raise err))
          (else
           (sql-eval con "RESET SESSION AUTHORIZATION")
           (conpool-put ecm-sql-conpool con))))))

(def (ecm-sql-e* fn . args)
  (def u (current-auth-user))
  (unless u (raise-auth-error 'ecm-sql-* "Auth user required"))
  (def r (ecm-user-role u))
  (apply ecm-sql-e role: r fn args))
#+end_src


* ~json-object<-ecm-sql-eval-query*~

The client speaks JSON. So does the server, and the database.

#+begin_src json
{
  name: "SQLStatement",
  type: Object,
  fields: {
    query: "String: The Query SQL text",
    args: "Array: The $args passed to this.query"
    cols: "Array: The names of the columns returned",
    rows: "Array of Arrays: A vector of vectors of the query results"
  }
}
#+end_src


#+begin_src scheme :tangle "database/eval-query.ss"
(export #t)
(import :drewc/db/postgresql :drewc/db/dbi
        :drewc/ftw :std/sugar ./connect
        (only-in :std/error error-irritants))

(def (json-object<-sql-eval-query db query . args)
  (def stmt (sql-prepare db query))
  (def cols (sql-columns stmt))
  (when (pair? args) (apply sql-bind stmt args))
  (def rows (sql-query stmt))
  (when (and (pair? rows)
             (not (vector? (car rows))))
    (set! rows (map vector rows)))
  (hash (query query)
        (args args)
        (cols cols)
        (rows rows)))

(def (json-object<-ecm-sql-eval-query* query . args)
  (apply ecm-sql-e* json-object<-sql-eval-query query args))
#+end_src

* /File/ ~database.ss~
#+begin_src scheme :tangle database.ss
(export (import: ./database/connect)
         (import: ./database/eval-query))
(import ./database/connect
        ./database/eval-query)
#+end_src
